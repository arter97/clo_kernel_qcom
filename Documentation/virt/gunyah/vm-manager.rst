.. SPDX-License-Identifier: GPL-2.0

=======================
Virtual Machine Manager
=======================

The Gunyah Virtual Machine Manager is a Linux driver to support launching
virtual machines using Gunyah.

Except for some basic information about the location of initial binaries,
most of the configuration about a Gunyah virtual machine is described in the
VM's devicetree. The devicetree is generated by userspace. Interacting with the
virtual machine is still done via the kernel and VM configuration requires some
of the corresponding functionality to be set up in the kernel. For instance,
sharing userspace memory with a VM is done via the GH_VM_SET_USER_MEM_REGION
ioctl. The VM itself is configured to use the memory region via the
devicetree.

Gunyah Functions
================

Components of a Gunyah VM's configuration that need kernel configuration are
called "functions" and are built on top of a framework. Functions are identified
by a string and have some argument(s) to configure them. They are typically
created by the `GH_VM_ADD_FUNCTION` ioctl.

Functions typically will always do at least one of these operations:

1. Create resource ticket(s). Resource tickets allow a function to register
   itself as the client for a Gunyah resource (e.g. doorbell or vCPU) and
   the function is given the pointer to the `struct gh_resource` when the
   VM is starting.

2. Register IO handler(s). IO handlers allow a function to handle stage-2 faults
   from the virtual machine.

Sample Userspace VMM
====================

A sample userspace VMM is included in samples/gunyah/ along with a minimal
devicetree that can be used to launch a VM. To build this sample, enable
CONFIG_SAMPLE_GUNYAH.

IOCTLs and userspace VMM flows
==============================

The kernel exposes a char device interface at /dev/gunyah.

To create a VM, use the GH_CREATE_VM ioctl. A successful call will return a
"Gunyah VM" file descriptor.

/dev/gunyah API Descriptions
----------------------------

GH_CREATE_VM
~~~~~~~~~~~~

Creates a Gunyah VM. The argument is reserved for future use and must be 0.

Gunyah VM API Descriptions
--------------------------

GH_VM_SET_USER_MEM_REGION
~~~~~~~~~~~~~~~~~~~~~~~~~

This ioctl allows the user to create or delete a memory parcel for a guest
virtual machine. Each memory region is uniquely identified by a label;
attempting to create two regions with the same label is not allowed. Labels are
unique per virtual machine.

While VMM is guest-agnostic and allows runtime addition of memory regions,
Linux guest virtual machines do not support accepting memory regions at runtime.
Thus, memory regions should be provided before starting the VM and the VM must
be configured to accept these at boot-up.

The guest physical address is used by Linux kernel to check that the requested
user regions do not overlap and to help find the corresponding memory region
for calls like GH_VM_SET_DTB_CONFIG. It must be page aligned.

memory_size and userspace_addr must be page-aligned.

The flags field of gh_userspace_memory_region accepts the following bits. All
other bits must be 0 and are reserved for future use. The ioctl will return
-EINVAL if an unsupported bit is detected.

  - GH_MEM_ALLOW_READ/GH_MEM_ALLOW_WRITE/GH_MEM_ALLOW_EXEC sets read/write/exec
    permissions for the guest, respectively.

To add a memory region, call GH_VM_SET_USER_MEM_REGION with fields set as
described above.

.. kernel-doc:: include/uapi/linux/gunyah.h
   :identifiers: gh_userspace_memory_region

GH_VM_SET_DTB_CONFIG
~~~~~~~~~~~~~~~~~~~~

This ioctl sets the location of the VM's devicetree blob and is used by Gunyah
Resource Manager to allocate resources. The guest physical memory should be part
of the primary memory parcel provided to the VM prior to GH_VM_START.

.. kernel-doc:: include/uapi/linux/gunyah.h
   :identifiers: gh_vm_dtb_config

GH_VM_START
~~~~~~~~~~~

This ioctl starts the VM.

GH_VM_ADD_FUNCTION
~~~~~~~~~~~~~~~~~~

This ioctl registers a Gunyah VM function with the VM manager. The VM function
is described with a `type` string and some arguments for that type. Typically,
the function is added before the VM starts, but the function doesn't "operate"
until the VM starts with GH_VM_START: e.g. vCPU ioclts will all return an error
until the VM starts because the vCPUs don't exist until the VM is started. This
allows the VMM to set up all the kernel functionality needed for the VM *before*
the VM starts.

.. kernel-doc:: include/uapi/linux/gunyah.h
   :identifiers: gh_fn_desc

The possible types are documented below:

.. kernel-doc:: include/uapi/linux/gunyah.h
   :identifiers: GH_FN_VCPU gh_fn_vcpu_arg GH_FN_IRQFD gh_fn_irqfd_arg GH_FN_IOEVENTFD gh_fn_ioeventfd_arg

Gunyah VCPU API Descriptions
----------------------------

A vCPU file descriptor is created after calling `GH_VM_ADD_FUNCTION` with the type `GH_FN_VCPU`.

GH_VCPU_RUN
~~~~~~~~~~~

This ioctl is used to run a guest virtual cpu.  While there are no
explicit parameters, there is an implicit parameter block that can be
obtained by mmap()ing the vcpu fd at offset 0, with the size given by
GH_VCPU_MMAP_SIZE. The parameter block is formatted as a 'struct
gh_vcpu_run' (see below).

GH_VCPU_MMAP_SIZE
~~~~~~~~~~~~~~~~~

The GH_VCPU_RUN ioctl communicates with userspace via a shared
memory region. This ioctl returns the size of that region. See the
GH_VCPU_RUN documentation for details.

.. kernel-doc:: include/uapi/linux/gunyah.h
   :identifiers: gh_vcpu_run gh_vm_exit_info
